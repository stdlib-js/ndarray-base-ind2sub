{
  "version": 3,
  "sources": ["../lib/assign.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar format = require( '@stdlib/string-format' );\nvar trunc = require( '@stdlib/math-base-special-trunc' );\n\n\n// MAIN //\n\n/**\n* Converts a linear index to an array of subscripts.\n*\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {IntegerArray} strides - stride array\n* @param {NonNegativeInteger} offset - location of the first indexed value **based** on the stride array\n* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)\n* @param {integer} idx - linear index\n* @param {string} mode - specifies how to handle a linear index which exceeds array dimensions\n* @param {(Array|TypedArray|Object)} out - destination object\n* @throws {RangeError} linear index must not exceed array dimensions\n* @returns {(Array|TypedArray|Object)} subscripts\n*\n* @example\n* var shape = [ 3, 3, 3 ];\n* var strides = [ 9, 6, 1 ];\n* var offset = 0;\n* var order = 'row-major';\n*\n* var s = [ 0, 0, 0 ];\n* var out = ind2sub( shape, strides, offset, order, 17, 'throw', s );\n* // returns [ 1, 2, 2 ]\n*\n* var bool = ( out === s );\n* // returns true\n*/\nfunction ind2sub( shape, strides, offset, order, idx, mode, out ) {\n\tvar ndims;\n\tvar len;\n\tvar k;\n\tvar s;\n\tvar i;\n\n\tndims = shape.length;\n\tlen = 1;\n\tfor ( i = 0; i < ndims; i++ ) {\n\t\tlen *= shape[ i ];\n\t}\n\tif ( mode === 'clamp' ) {\n\t\tif ( idx < 0 ) {\n\t\t\tidx = 0;\n\t\t} else if ( idx >= len ) {\n\t\t\tidx = len - 1;\n\t\t}\n\t} else if ( mode === 'wrap' ) {\n\t\tif ( idx < 0 ) {\n\t\t\tidx += len; // slight optimization to avoid modulo arithmetic when |idx| <= len\n\t\t\tif ( idx < 0 ) {\n\t\t\t\tidx %= len;\n\t\t\t\tif ( idx !== 0 ) {\n\t\t\t\t\tidx += len;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( idx >= len ) {\n\t\t\tidx -= len; // slight optimization to avoid modulo arithmetic when len < idx <= 2*len\n\t\t\tif ( idx >= len ) {\n\t\t\t\tidx %= len;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ( mode === 'normalize' && idx < 0 ) {\n\t\t\tidx += len;\n\t\t}\n\t\tif ( idx < 0 || idx >= len ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Linear index must not exceed array dimensions. Number of array elements: `%u`. Value: `%d`.', len, idx ) );\n\t\t}\n\t}\n\tif ( offset === 0 ) {\n\t\tif ( order === 'column-major' ) {\n\t\t\tfor ( i = 0; i < ndims; i++ ) {\n\t\t\t\ts = idx % shape[ i ];\n\t\t\t\tidx -= s;\n\t\t\t\tidx /= shape[ i ];\n\t\t\t\tout[ i ] = s;\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t\t// Case: row-major\n\t\tfor ( i = ndims-1; i >= 0; i-- ) {\n\t\t\ts = idx % shape[ i ];\n\t\t\tidx -= s;\n\t\t\tidx /= shape[ i ];\n\t\t\tout[ i ] = s;\n\t\t}\n\t\treturn out;\n\t}\n\tif ( order === 'column-major' ) {\n\t\tfor ( i = ndims-1; i >= 0; i-- ) {\n\t\t\ts = strides[ i ];\n\t\t\tif ( s < 0 ) {\n\t\t\t\tk = trunc( idx/s );\n\t\t\t\tidx -= k * s;\n\t\t\t\tout[ i ] = shape[ i ] - 1 + k;\n\t\t\t} else {\n\t\t\t\tk = trunc( idx/s );\n\t\t\t\tidx -= k * s;\n\t\t\t\tout[ i ] = k;\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\t// Case: row-major\n\tfor ( i = 0; i < ndims; i++ ) {\n\t\ts = strides[ i ];\n\t\tif ( s < 0 ) {\n\t\t\tk = trunc( idx/s );\n\t\t\tidx -= k * s;\n\t\t\tout[ i ] = shape[ i ] - 1 + k;\n\t\t} else {\n\t\t\tk = trunc( idx/s );\n\t\t\tidx -= k * s;\n\t\t\tout[ i ] = k;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = ind2sub;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar getSubscripts = require( './assign.js' );\n\n\n// MAIN //\n\n/**\n* Converts a linear index to an array of subscripts.\n*\n* ## Notes\n*\n* -   The function accepts the following \"modes\":\n*\n*     -   **throw**: throw an error when a linear index exceeds array dimensions.\n*     -   **normalize**: normalize negative indices and throw an error when a linear index exceeds array dimensions.\n*     -   **wrap**: wrap around a linear index exceeding array dimensions using modulo arithmetic.\n*     -   **clamp**: set a linear index exceeding array dimensions to either `0` (minimum linear index) or the maximum linear index.\n*\n* -   When provided a stride array containing negative strides, if an `offset` is greater than `0`, the function interprets the linear index as an index into the underlying data buffer for the array, thus returning subscripts from the perspective of that buffer. If an `offset` is equal to `0`, the function treats the linear index as an index into an array view, thus returning subscripts from the perspective of that view.\n*\n*     ```text\n*     Dims: 2x2\n*     Buffer: [ 1, 2, 3, 4 ]\n*\n*     View = [ a00, a01,\n*              a10, a11 ]\n*\n*     Strides: 2,1\n*     Offset: 0\n*\n*     View = [ 1, 2,\n*              3, 4 ]\n*\n*     Strides: 2,-1\n*     Offset: 1\n*\n*     View = [ 2, 1,\n*              4, 3 ]\n*\n*     Strides: -2,1\n*     Offset: 2\n*\n*     View = [ 3, 4,\n*              1, 2 ]\n*\n*     Strides: -2,-1\n*     Offset: 3\n*\n*     View = [ 4, 3,\n*              2, 1 ]\n*     ```\n*\n*     ```javascript\n*     var shape = [ 2, 2 ];\n*     var order = 'row-major';\n*     var strides = [ -2, 1 ];\n*     var offset = 2;\n*     var mode = 'throw';\n*\n*     // From the perspective of a view...\n*     var s = ind2sub( shape, strides, 0, order, 0, mode );\n*     // returns [ 0, 0 ]\n*\n*     s = ind2sub( shape, strides, 0, order, 1, mode );\n*     // returns [ 0, 1 ]\n*\n*     s = ind2sub( shape, strides, 0, order, 2, mode );\n*     // returns [ 1, 0 ]\n*\n*     s = ind2sub( shape, strides, 0, order, 3, mode );\n*     // returns [ 1, 1 ]\n*\n*     // From the perspective of an underlying buffer...\n*     s = ind2sub( shape, strides, offset, order, 0, mode );\n*     // returns [ 1, 0 ]\n*\n*     s = ind2sub( shape, strides, offset, order, 1, mode );\n*     // returns [ 1, 1 ]\n*\n*     s = ind2sub( shape, strides, offset, order, 2, mode );\n*     // returns [ 0, 0 ]\n*\n*     s = ind2sub( shape, strides, offset, order, 3, mode );\n*     // returns [ 0, 1 ]\n*     ```\n*\n*     In short, from the perspective of a view, view data is always ordered.\n*\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {IntegerArray} strides - stride array\n* @param {NonNegativeInteger} offset - location of the first indexed value **based** on the stride array\n* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)\n* @param {integer} idx - linear index\n* @param {string} mode - specifies how to handle a linear index which exceeds array dimensions\n* @throws {RangeError} linear index must not exceed array dimensions\n* @returns {Array} subscripts\n*\n* @example\n* var shape = [ 3, 3, 3 ];\n* var strides = [ 9, 6, 1 ];\n* var offset = 0;\n* var order = 'row-major';\n*\n* var s = ind2sub( shape, strides, offset, order, 17, 'throw' );\n* // returns [ 1, 2, 2 ]\n*/\nfunction ind2sub( shape, strides, offset, order, idx, mode ) {\n\treturn getSubscripts( shape, strides, offset, order, idx, mode, zeros( shape.length ) ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nmodule.exports = ind2sub;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Convert a linear index to an array of subscripts.\n*\n* @module @stdlib/ndarray-base-ind2sub\n*\n* @example\n* var ind2sub = require( '@stdlib/ndarray-base-ind2sub' );\n*\n* var shape = [ 3, 3, 3 ];\n* var strides = [ 9, 6, 1 ];\n* var offset = 0;\n*\n* var s = ind2sub( shape, strides, offset, 'row-major', 17, 'throw' );\n* // returns [ 1, 2, 2 ]\n*\n* @example\n* var ind2sub = require( '@stdlib/ndarray-base-ind2sub' );\n*\n* var shape = [ 3, 3, 3 ];\n* var strides = [ 9, 6, 1 ];\n* var offset = 0;\n*\n* var s = [ 0, 0, 0 ];\n* var out = ind2sub.assign( shape, strides, offset, 'row-major', 17, 'throw', s );\n* // returns [ 1, 2, 2 ]\n*\n* var bool = ( out === s );\n* // returns true\n*/\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar main = require( './main.js' );\nvar assign = require( './assign.js' );\n\n\n// MAIN //\n\nsetReadOnly( main, 'assign', assign );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAS,QAAS,uBAAwB,EAC1CC,EAAQ,QAAS,iCAAkC,EA+BvD,SAASC,EAASC,EAAOC,EAASC,EAAQC,EAAOC,EAAKC,EAAMC,EAAM,CACjE,IAAIC,EACAC,EACAC,EACAC,EACAC,EAIJ,IAFAJ,EAAQP,EAAM,OACdQ,EAAM,EACAG,EAAI,EAAGA,EAAIJ,EAAOI,IACvBH,GAAOR,EAAOW,CAAE,EAEjB,GAAKN,IAAS,QACRD,EAAM,EACVA,EAAM,EACKA,GAAOI,IAClBJ,EAAMI,EAAM,WAEFH,IAAS,OACfD,EAAM,GACVA,GAAOI,EACFJ,EAAM,IACVA,GAAOI,EACFJ,IAAQ,IACZA,GAAOI,KAGEJ,GAAOI,IAClBJ,GAAOI,EACFJ,GAAOI,IACXJ,GAAOI,YAIJH,IAAS,aAAeD,EAAM,IAClCA,GAAOI,GAEHJ,EAAM,GAAKA,GAAOI,EACtB,MAAM,IAAI,WAAYX,EAAQ,gHAAiHW,EAAKJ,CAAI,CAAE,EAG5J,GAAKF,IAAW,EAAI,CACnB,GAAKC,IAAU,eAAiB,CAC/B,IAAMQ,EAAI,EAAGA,EAAIJ,EAAOI,IACvBD,EAAIN,EAAMJ,EAAOW,CAAE,EACnBP,GAAOM,EACPN,GAAOJ,EAAOW,CAAE,EAChBL,EAAKK,CAAE,EAAID,EAEZ,OAAOJ,CACR,CAEA,IAAMK,EAAIJ,EAAM,EAAGI,GAAK,EAAGA,IAC1BD,EAAIN,EAAMJ,EAAOW,CAAE,EACnBP,GAAOM,EACPN,GAAOJ,EAAOW,CAAE,EAChBL,EAAKK,CAAE,EAAID,EAEZ,OAAOJ,CACR,CACA,GAAKH,IAAU,eAAiB,CAC/B,IAAMQ,EAAIJ,EAAM,EAAGI,GAAK,EAAGA,IAC1BD,EAAIT,EAASU,CAAE,EACVD,EAAI,GACRD,EAAIX,EAAOM,EAAIM,CAAE,EACjBN,GAAOK,EAAIC,EACXJ,EAAKK,CAAE,EAAIX,EAAOW,CAAE,EAAI,EAAIF,IAE5BA,EAAIX,EAAOM,EAAIM,CAAE,EACjBN,GAAOK,EAAIC,EACXJ,EAAKK,CAAE,EAAIF,GAGb,OAAOH,CACR,CAEA,IAAMK,EAAI,EAAGA,EAAIJ,EAAOI,IACvBD,EAAIT,EAASU,CAAE,EACVD,EAAI,GACRD,EAAIX,EAAOM,EAAIM,CAAE,EACjBN,GAAOK,EAAIC,EACXJ,EAAKK,CAAE,EAAIX,EAAOW,CAAE,EAAI,EAAIF,IAE5BA,EAAIX,EAAOM,EAAIM,CAAE,EACjBN,GAAOK,EAAIC,EACXJ,EAAKK,CAAE,EAAIF,GAGb,OAAOH,CACR,CAKAV,EAAO,QAAUG,ICpJjB,IAAAa,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAQ,QAAS,0BAA2B,EAC5CC,EAAgB,IAyGpB,SAASC,EAASC,EAAOC,EAASC,EAAQC,EAAOC,EAAKC,EAAO,CAC5D,OAAOP,EAAeE,EAAOC,EAASC,EAAQC,EAAOC,EAAKC,EAAMR,EAAOG,EAAM,MAAO,CAAE,CACvF,CAKAJ,EAAO,QAAUG,ICnFjB,IAAIO,EAAc,QAAS,uDAAwD,EAC/EC,EAAO,IACPC,EAAS,IAKbF,EAAaC,EAAM,SAAUC,CAAO,EAKpC,OAAO,QAAUD",
  "names": ["require_assign", "__commonJSMin", "exports", "module", "format", "trunc", "ind2sub", "shape", "strides", "offset", "order", "idx", "mode", "out", "ndims", "len", "k", "s", "i", "require_main", "__commonJSMin", "exports", "module", "zeros", "getSubscripts", "ind2sub", "shape", "strides", "offset", "order", "idx", "mode", "setReadOnly", "main", "assign"]
}
